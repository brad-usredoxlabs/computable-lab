# Agent Rules — computable-lab

These rules are non-negotiable.
If a choice violates these rules, it is incorrect.

---

## 1. Prime Directive

**If something can be expressed as data, it must be expressed as data.**

Code exists only to:
- Load schemas and specs
- Validate records (structural)
- Lint records (business rules from data)
- Render UI from schema/UI specs
- Execute state machines
- Perform GitHub CRUD
- Build derived graphs and indices

---

## 1.1 Schema-First Protocol (Mandatory on First Attempt)

On the FIRST attempt at any feature or refactor, the agent MUST:

1) Identify which parts are:
   - Structural constraints → `*.schema.yaml`
   - Business rules → `*.lint.yaml`
   - UI behavior → `*.ui.yaml`

2) Propose the data/spec changes FIRST (schemas/lint/ui), even if code changes are also needed.

3) Only then propose minimal generic code changes to:
   - load specs
   - validate (Ajv)
   - interpret lint DSL
   - render UI from spec
   - persist envelopes via repo adapter

If the agent starts by writing TypeScript that encodes business behavior, defaults, or schema-specific branching, it is incorrect.

If the agent believes something cannot be expressed as data/spec:
- it MUST explain why, and
- propose a generic DSL extension (no schema-specific code paths).

---

## 2. No Hard-Coded Business Logic (Ever)

- Business rules MUST live in `*.lint.yaml` (Lint DSL).
- UI rules MUST live in `*.ui.yaml`.
- Structural constraints MUST live in `*.schema.yaml`.
- **No “built-in rules” are allowed in TypeScript.** If a default rule is needed, it must ship as a `*.lint.yaml` file in the repo.

Forbidden patterns:
- `businessRules.ts`
- `MaterialRules.ts`, `ClaimValidator.ts`, etc.
- `if (schemaId === '...')` branches in validators, services, UI, or adapters
- inline regexes or required-field logic tied to specific schemas in code

If a rule cannot be expressed in the DSL, the agent must:
1) explain why the DSL is insufficient, and
2) propose a **generic DSL extension** (no schema-specific code paths).

---

## 3. Record Identity Rules

- `recordId` is canonical
- `@id` is always derived
- `@context` is always derived
- Users never edit derived fields

---

## 3.1 Envelope-First CRUD (Non-Negotiable)

CRUD APIs MUST be envelope-first.

- Canonical identity is `RecordEnvelope.recordId`
- Code MUST NOT assume record payload contains fields like `id`, `createdAt`, `updatedAt`, `createdBy`
- Code MUST NOT copy/smuggle those fields between payload and envelope

If metadata exists, it lives in `RecordEnvelope.meta` and is either:
- provided explicitly by the caller/context, or
- derived deterministically from repo state / event graph (never from time/random).

---

## 4. Schema Triplet Is Mandatory

Every record schema MUST have:
- `*.schema.yaml`
- `*.ui.yaml`
- `*.lint.yaml`

Additionally:
- The lint DSL itself is validated by `schema/lint/lint-v1.schema.yaml`.

If a feature cannot be implemented using these specs,
the agent must stop and explain why.

---

## 5. File System and Naming

- Records live only under `computable-lab/records/`
- Schemas/specs live only under `computable-lab/schema/`
- File naming: `RecordId__human-name.yaml`
- The human-name portion is cosmetic only

---

## 6. GitHub Is the Authority

- GitHub API is the source of truth
- No local DB may act as authority
- Local caches must be derived and disposable
- Lint/validation must run on fetched repo state (no network during lint)

---

## 7. Determinism and Purity

All derivations must be:
- Deterministic
- Pure functions
- Covered by tests

This includes:
- `@id` derivation
- JSON-LD generation
- Graph edges
- Index construction

No time-based defaults, randomness, or environment-dependent logic in derivations.

---

## 7.1 Tests Are the Gate (No “Type-Only” Fixes)

Any change that affects validation, schema loading, dependency resolution, storage behavior, or determinism MUST be accompanied by a test that fails before the change and passes after.

Forbidden:
- “Fixing” compile errors by editing `types.ts` or adding `any` without a failing behavioral test.
- Changing an interface to accommodate the current implementation when the desired behavior is known.

Required:
- At least one behavioral test for each root cause fixed.
- Prefer permutation stability tests for schema loading and `$ref` resolution.

---

## 7.2 Exact Optional Property Semantics (Critical)

The project is compiled with `exactOptionalPropertyTypes: true`.
This setting is intentional and MUST be respected at all times.

### Contract Semantics

For any optional property declared as:

```ts
prop?: T
```

the semantics are:

- The property is either:
  - **absent**, or
  - **present with a value of type `T`**
- The property MUST NOT be present with the value `undefined`.

This is a semantic contract, not a TypeScript convenience.

### Forbidden Fixes

When encountering TypeScript errors related to optional properties, the agent MUST NOT:

- Add `| undefined` to optional property types
- Modify shared interfaces (e.g. `types/common.ts`) to accept `undefined`
- Use type assertions (`as Type`) to silence the error
- Introduce helper types or wrapper types to bypass the contract
- “Be more explicit about the type” instead of fixing object construction

### Required Fix Pattern

When constructing objects with optional properties, the agent MUST conditionally include the property only when it is defined.

Canonical pattern:

```ts
{
  ...(prop !== undefined ? { prop } : {})
}
```

Explicitly incorrect patterns:

```ts
{ prop }                    // ❌ may include undefined
{ prop: undefined }         // ❌ explicit undefined
{ prop: prop ?? undefined } // ❌ explicit undefined
{ ...obj, prop }            // ❌ unsafe if prop is optional
```

### Enforcement Rule

If a TypeScript error arises due to `exactOptionalPropertyTypes`, the agent MUST:

1) Fix the object construction logic  
2) Preserve the original type contracts  
3) Add or update tests if needed to confirm omission behavior

Editing shared type definitions to accommodate invalid object construction is forbidden.

---

## 7.3 Ajv Integration: No Internals, No Mutable Rebuilds (Critical)

Ajv is an external authority. The agent MUST NOT depend on Ajv private/internal fields or rebuild Ajv instances in-place as a “workaround”.

Forbidden patterns:
- Reading or mutating Ajv internals like `ajv.formats`, `ajv.schemas`, or other undocumented fields
- “Rebuilding Ajv” inside a method (e.g., `removeFormat()` that constructs a new Ajv and tries to copy state)
- Any approach that might silently drop formats, meta-schemas, keywords, or schema pool state

Required approach:
- Configure Ajv once at construction time (formats/keywords/options)
- Treat format registration as startup configuration, not mutable runtime state
- If removal is requested: either (a) **do not support it** (throw a well-named error), or (b) implement a documented, deterministic alternative approved by tests.

---

## 7.4 Ajv Validator API Stability: No Method Collisions (Critical)

The agent MUST NOT create conflicting method names/signatures on a single class.

Forbidden:
- Defining multiple methods with the same name intending overloads (TypeScript does not allow runtime overloads)
- Reusing the same method name for two different interfaces (e.g., `validate(data,schema)` and `validate(uri,data)`)

Required:
- Use distinct names for distinct behaviors, e.g.:
  - `validate(data, schema)` for `Validator`
  - `validateByUri(uri, data)` for Ajv backend usage
- Ensure interface contracts (`Validator`, `AjvBackend`, etc.) match the implemented names exactly.

---

## 7.5 Validator Caching Must Be Coherent (Critical)

If caching compiled validators:
- The cache key strategy MUST be single, explicit, and consistent.

Forbidden:
- Claiming “content-based caching” while keying by `$id` (URI-based) in some cases and content in others
- Leaving stale compiled validators after `addSchema/removeSchema` or registry updates

Required:
- Pick one:
  - URI-based cache keyed by canonical schema URI, and invalidate on schema changes; OR
  - content-hash cache keyed purely by canonicalized schema content, never `$id`.
- Add a test proving cache invalidation correctness.

---

## 8. Layer Boundaries (Do Not Mix)

- Repo adapter: text in/out, no domain semantics
- Record store: parse/serialize + call validate/lint
- Ajv validator: structural validation only
- Lint engine: generic interpreter for lint DSL only
- UI renderer: schema/UI-driven, no domain branching
- Graph builder: deterministic derivations only

If a file “knows” a schema name, it’s probably in the wrong layer.

---

## 8.1 No Dumping Grounds (Critical)

Certain files are “load-bearing” and MUST NOT be used as a workaround to avoid fixing root causes.

### Protected Files (Do Not Use As Fix Targets)

The agent MUST NOT modify these files except under the narrow conditions below:

- `src/validation/types.ts`
- `src/types/**`
- `src/index.ts`
- any file named `*types.ts`, `*constants.ts`, `*utils.ts`, `*helpers.ts` **unless** the change is clearly generic and required by a failing test.

### The Dumping Ground Smell

A change is considered “dumping ground” behavior if it:
- makes a type looser (adds `any`, `unknown`, broad unions, optional fields) to silence errors
- changes interfaces to match broken code instead of changing code to match the intended contract
- moves logic into “types/constants/utils” to avoid editing the correct layer
- adds new “catch-all” types, exceptions, or flags without a test that demonstrates necessity

### Allowed Changes to Protected Files (Rare)

Edits to protected files are allowed ONLY if ALL are true:
1) A failing test exists that demonstrates a real bug in the current contract.
2) The change is the minimal correction to make the contract precise (usually *stricter*, not looser).
3) A second test is added to prevent regression.

If any of (1)-(3) are missing, editing a protected file is forbidden.

### Two-Phase Fix Rule

When a bug touches types/contracts:
- Phase A: Write/enable a failing test that reproduces the bug.
- Phase B: Fix the bug in the correct implementation layer.
- Phase C: Only then adjust types/contracts if the test shows the contract itself is wrong.

Skipping Phase A is not allowed.

---

## 8.2 Validation Constitution (Enforced)

- Ajv is the single authority for structural validation and meta-schema validation.
- SchemaRegistry MUST NOT implement “fake” validation logic (no `typeof` checks, no stub meta-validation).
- SchemaRegistry MUST enforce identity + hashing + dependency graph, and MUST integrate with Ajv via `addSchema/getSchema`.
- Any placeholder validator behavior is forbidden.

---

## 9. Allowed Stack

- TypeScript (strict)
- React (declarative only)
- Ajv (schema validation authority)
- XState (workflow execution)
- ESLint (code linting)
- JSON-LD libraries as needed

Avoid libraries that hide logic in configuration-less magic.

---

## 10. When in Doubt

Before writing code, ask:
> Can this be expressed as schema, lint, UI spec, or data?

If yes, do not write code.

---

# Agent Checklists — computable-lab

## Definition of Done (Any Change)

- [ ] Schema-first protocol followed (specs proposed before code)
- [ ] No domain logic or defaults in code
- [ ] No schema-name branching in code
- [ ] Tests added (fail before / pass after) for behavioral changes
- [ ] Determinism preserved (no time/random/environment in derivations)
- [ ] Protected files unchanged OR change justified per 8.1 + tests
- [ ] Ajv rules honored (no internals, no runtime rebuild hacks, coherent caching, no method collisions)

---

## New Schema Checklist

- [ ] schema.yaml exists
- [ ] ui.yaml exists
- [ ] lint.yaml exists
- [ ] Example record exists
- [ ] Validation tested
- [ ] Lint tested

---

## Security Checklist

- [ ] No API keys in repo
- [ ] app.settings.yaml gitignored
- [ ] No secrets in tests
